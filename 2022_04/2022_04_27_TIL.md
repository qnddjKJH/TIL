### JPA 활용 2편
 - OneToX 관계
 - V4 : DTO 반환
    - 비슷한 Dto 를 왜 재사용 하지 않는 이유
        - 리포지토리에서 어떤 DTO 를 알아야하는지 아는게 좋다
        - 리포지토리가 컨트롤러를 참조하는 순환관계가 되어 버린다.
    - Query : 루트 1번, 컬렉션 N 번 실행
    - ToOne (N:1, 1:1) 관계들을 먼저 조회하고
    ToMany (1:N) 관계는 각각 별도로 메소드를 만들어 처리한다.
        - 이런 방식을 선택한 이유는?
        1. ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다 --> 페이징 가능
        2. ToMany(1:N) 조인하면 row 수가 증가 --> 예측불가, 페이징 불가 (하이버네이트 경고)
    - row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화 하기 쉬움 -> 한번에 조회
    - ToMany 관계 최적화 하기 어려움 --> 별도의 메서드로 조회
 - V5 : JPA에서 DTO 직접 조회 - 컬렉션 조회 최적화
    - 최적화를 거치게 되면 쿼리는 총 2번 나간다. 루트 1번, 컬렉션 1번
    - ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 orderId로 ToMany 관계인
    `OrderItem` 을 한꺼번에 조회
    - MAP 을 사용해서 매칭 성능 향상 O(1)
 - V6 : JPA에서 DTO 직접 조회 - 플랫 데이터 최적화
    - 쿼리가 단 한번 나가게끔 모든 필요한 data 를 dto 에 담고
    전부 join 한다.
    - API 스펙이 바뀐다.
        - 원하는 API 스펙으로 바꿔줘야 한다. 예) OrderFlatDto -> OrderQeuryDto
    - 전부 join 했기에 중복이 생길 수 밖에 없다.
        - 모든 중복을 한땀..한땀...처리해주는 기능을 만든다.
    장점 : 쿼리 1번
    단점 : 데이터가 크면 V5 가 더 나음, 애플리케이션 추가 작업이 많음, 페이징 불가능



 
 - 번외 : Spring Data JPA
    - JpaRepository 라는 인터페이스 제공
    기본적인 CRUD 기능이 모두 제공된다.(일반적으로 상상가능한 모든 기능)
    - findByMembershipPoint 처럼 일반화 하기 어려운 기능도 메서드 이름으로
    정확한 JPQL 쿼리를 실행하여 준다
        - `select m from member m where m.membershippoint = :membershippoint`
    - 개발자는 인터페이스만 만들면 된다. 구현체는 스프링 데이터 JPA 가 애플리케이션
    실행 시점에 주입해준다.

지금까지 JPQL 을 사용하면서 편리하면서, 불편한 느낌을 받고 있다.
--> QueryDSL 로 편하게 가져갈 수 있다

### Side Project - ByeBuying
 - 순수 글쓴이의 사이드 프로젝트는 아님
    - 직접 만드는 것보다 성능 최적화, 리팩토링, 구조 변경(MSA)을 목표로 한 프로젝트이다.
 - Domain 재설계 시작
    - JPA 배운 내용을 적용해 나갈 예정
    - 현재는 연관관계의 탈을 쓴 단일 테이블
        - id 값을 직접 저장중 - 연관관계 매핑이 안되어 있다.
    - 진행중 ~ 