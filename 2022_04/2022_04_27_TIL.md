### 코딩 연습
 - 이항 계수
    - 파스칼의 삼각형

### 자료구조
 - 힙 
    - 시간 복잡도
        - depth (트리의 높이) 를 h 라고 표기하면
        - n개의 노드를 가지는 heap 에 데이터 삽입 또는 삭제시, 최악의 경우 root 노드 에서 leaf 노드까지 비교해야 함 h = log 2 n 에 가까움
            - 복잡도 O ( log 2 n)
            - 한번 실행시마다 50%의 실행할 수도 있는 명령을 제거하는 의미
            - 즉 50% 의 실행시간을 단축 시킬 수 있다는 것을 의미

### JPA 활용 2편
 - OneToX 관계
    - v3
        - 페치 조인 시 페이징 불가
            - 컬렉션을 페치 조인하면 일대다 조인이 발생
            데이터가 예측할 수 없이 증가
            - 하이버네이트는 경고 로그를 남기고 모든 DB 데이터를 읽어서
            메모리에서 페이징을 시도
            - 최악의 경우 아웃 오브 메모리 장애
    - v3.1 : **한계돌파**
        - 해결 방안
            1. ToOne 관계를 모두 페치조인 한다.(ToOne 관계는 row 수를 증가시키지 않음
            페이징 쿼리에 영향을 주지 않는다. -> 사용가능)
            2. 컬렉션은 LAZY LOADING 으로 조회한다.
            3. 지연 로딩 성능 최적화를 위해 
            `hibernate.default_batch_fetch_size`, `@BatchSize` 를 적용한다.
                - `hibernate.default_batch_fetch_size` : 글로벌 설정
                - `@BatchSize` : 개별 최적화 (클래스 단위, 필드 단위)
                -이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 size만큼 IN 쿼리로 조회한다.
        - 장점
            - 쿼리 호출 수가 `1+N` -> `1+1` 로 최적화 된다.
            - 조인보다 DB 데이터 전송량이 최적화 된다. (중복데이터 최적화)
            - 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가 But DB 데이터 전송량 감소
            - 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 가능하다.
        - 결론
            - ToOne 관계는 페치 조인 하여 쿼리 수를 줄이고 나머지는 `hibernate.default_batch_fetch_size` 로 **최적화 하자**

        - ※ `hibernate.default_batch_fetch_size` 의 최적 크기는?
            - 최대 사이즈는 정해져 있다. `MAX = 1000`
                - 데이터베이스에서 IN 절 파라미터를 1000개로 제한하는 경우가 있기 때문
            - 권장 사이즈는 **100 ~ 1000**개이다.
            - 1000 개로 잡으면 무조건 좋아보이지만 매 호출시 1000개의 데이터를 뽑아 가기 때문에 순간 부하률이 높아지기 떄문에 무조건 좋지는 않다.
            - 그러므로 하드웨어 사양에 따라서 적절히 조절해주자.
            - 메모리는 100이든 1000이든 전체 데이터를 로딩하기 떄문에(제한해서 사용하는 경우가 드물다) 사용량은 똑같다.

### Side Project - ByeBuying
 - 순수 글쓴이의 사이드 프로젝트는 아님
    - 직접 만드는 것보다 성능 최적화, 리팩토링, 구조 변경(MSA)을 목표로 한 프로젝트이다.
 - Domain 재설계 시작
    - JPA 배운 내용을 적용해 나갈 예정
    - 현재는 연관관계의 탈을 쓴 단일 테이블
        - id 값을 직접 저장중 - 연관관계 매핑이 안되어 있다.