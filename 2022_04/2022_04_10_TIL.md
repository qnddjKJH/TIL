### 코딩 테스트 강의 자료구조 파트
- 빅오 표기법
- 해쉬 테이블
    - 장점
        - 데이터 일기/저장 속도 빠름
        - 중복 데이터 확인이 쉬움
    - 단점
        - 저장공간이 많이 필요하다(미리 저장공간을 할당하므로)
        - **여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위해 별도 자료구조 필요**
    - 해쉬 함수
        - Chaining 기법 (개방 해싱 - Open Hashing)
            - 해쉬 테이블 외부에서 해결법을 찾음
            - Linked List 사용
        - Linear 기법 (폐쇄 해싱 - Close Hashing)
            - 해쉬 테이블 내부에서 해결법을 찾음
            - 중복 주소 -> 다음 주소로 이동
    - 주요 용도
        - 검색
        - 저장, 삭제 빈번한 경우
        - 캐쉬 구현시 (중복 확인이 쉬워서)
### JPA
- JPQL
    - 조인
        - 내부 조인, 외부 조인, 세타 조인 (이건 sql 기본)
        - ON 절  (JPA 2.1 부터 지원)
            - 조인 대상 필터링
            - 연관관계 없는 엔티티 외부 조인 ( 하이버네이트 5.1 부터)
    - 서브쿼리
        - SQL 과 비슷하다.
    - 기본함수
        - Dialect 에서 기본적으로 제공해준다.
        - 사용자 정의 함수
            - 사용하는 Dialect 를 상속받아 원하는 함수를 작성할 수 있다.
    - JPQL 타입 표현과 기타식
        - 기본적으로 JPQL 에서 타입을 사용하는 법
    - 조건식 (CASE, COALESCE 등등)
    - JPQL 함수
- 경로 표현식
    - 묵시적 내부 조인이 일어나는 경우
        - 단일 값 연관 경로
        - 컬렉션 값 연관 경로
    - 가급적 묵시적 조인 보다는 명시적 조인을 사용
    - 묵시적 조인은 조인이 일어나는 상황을 파악하기 어렵기 때문에 SQL 성능 튜닝에 난항을 겪는다.

- **페치 조인** 
정말정말 중요한 페치 조인 파트1
    - JPQL 성능 최적화를 위한 기능
    - 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회
    - 사실상 즉시로딩과 비슷
        - 원하는 대로 객체 그래프를 명시적으로 동적인 타이밍에 정할 수 있는 점이 차별점이다.
    - 일대다 컬렉션 페치 조인
        - 컬렉션 페치 조인은 뻥튀기가 된다.
        - 하나의 데이터와 연결된 다수의 데이터이므로 당연함
    - 중복제거
        - SQL 의 DISTINCT
            - SQL 의 DISTINCT 만으로는 중복 제거가 되지 않음
        - JPQL 의 DISTINCT
            - SQL 에 DISTINCT 추가
            - 애플리케이션에서 엔티티를 중복 제거 한다.
    - 일반 조인과 페치 조인의 차이
        - 일반 조인
            - 일반 조인 실행시 연관된 엔티티를 조회하지 않는다.
            - JPQL 은 결과를 반환할 때 연관관계 고려하지 않음
            - 단지 SELECT 절에 지정한 엔티티만 조회
        - 페치 조인
            - 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회한다. == 사실상 즉시로딩으로 봐도 무관 (하지만 같은건 아니다 차이점은 있음)
            - **페치 조인은 객체 그래프를 SQL 한 번에 조회하는 개념**(쿼리의 양이 줄어들어 성능 상승)


- 다형성 쿼리
    - TYPE : 조회 대상을 특정 자식으로 한정
    - TREAT
        - 자바의 타입 캐스팅과 유사
        - 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
        - FROM, WHERE, SELECT (하이버네이트 지원)

- 엔티티 직접 사용
    - 엔티티를 직접 사용하면 해당 엔티티의 기본 키 값을 사용합니다.
    - 엔티티 직접 사용 - 외래 키 값
        - 마찬가지로 외래 객체를 사용해도 외래 키 값을 사용
    
- Named 쿼리
    - 미리 정의해서 이름을 부여해두고 사용하는 JPQL
    - @NamedQuery 어노테이션 사용
    - 정적 쿼리만 가능하다
    - 어노테이션, XML 에 정의 가능
    - 애플리케이션 로딩 시점에 초기화 -> 재사용
    - 애플리케이션 로딩 시점에 쿼리 검증 가능!!!
        - 개발할 때 가장 좋은 에러는 컴파일 에러다!!
- 벌크 연산
    - executeUpdate() 사용
    - 리턴값은 영향 받은 엔티티 수 반환
    - UPDATE, DELETE 지원
    - INSERT (insert into ... select, 하이버네이트 지원)

    - 주의점
        - 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리를 넣는다.
    - 해결방법
        - 컨텍스트가 비어 있다면 벌크 연산 먼저 수행
        - 벌크 연산 이후 영속성 컨텍스트 초기화